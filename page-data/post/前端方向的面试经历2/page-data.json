{"componentChunkName":"component---src-components-post-jsx","path":"/post/前端方向的面试经历2","result":{"data":{"markdownRemark":{"id":"f4601566-d342-5c26-9d74-4ec686a9c0fa","frontmatter":{"date":"June 04, 2020","draft":null,"tags":null,"title":"前端方向的面试经历2"},"html":"<p>记录一次前端方向的面试经历（其实是第三次，其实很多问题都重叠了，但我还是答不上来）。</p>\n<ol>\n<li>\n<p>JavaScript 原型链， <code class=\"language-text\">__proto__</code> 关键字</p>\n<p>答：眼熟 <code class=\"language-text\">__proto__</code>，但我不知什么意思（大意）。</p>\n<hr>\n<p>对象的原型对应 <code class=\"language-text\">__proto__</code> ，函数的原型对应 <code class=\"language-text\">prototype</code></p>\n<p>肤浅的证明：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nbar<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">.</span>prototype\n<span class=\"token comment\">// true</span></code></pre></div>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">继承与原型链</a></p>\n<p><code class=\"language-text\">__proto__</code> 不是 JS 的标准属性，但却是事实标准。</p>\n<p>标准的方式是用 <code class=\"language-text\">Object.getPrototypeOf(obj)</code> 和 <code class=\"language-text\">Object.setPrototypeOf(obj)</code> 。不过据说性能反而会降低？</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\">Object.getPrototypeOf()</a></p>\n<p>看来 JS 根本没有类这种东西？类实际上都是函数。 不过 Java 这种，到 JVM bytecode 层面也许也没有类的概念了？</p>\n</li>\n<li>\n<p>HTTP 缓存</p>\n<p>答：只眼熟 <code class=\"language-text\">Last-Modified</code> ，具体作用不知，别的也不知（</p>\n<hr>\n<p>一手的信息 RFC 文档还挺长的，43 页...</p>\n<p>Hypertext Transfer Protocol (HTTP/1.1): Caching</p>\n<p><a href=\"https://tools.ietf.org/pdf/rfc7234.pdf\"></a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\">HTTP 缓存</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">HTTP 缓存 | Web Fundamentals | Google Developers</a></p>\n<p>简要来说，就是每个请求的资源的缓存控制都通过 <code class=\"language-text\">Cache-Control</code> 的 HTTP 头来制定。</p>\n<ul>\n<li><code class=\"language-text\">no-store</code> 不缓存资源</li>\n<li><code class=\"language-text\">no-cache</code> 每次请求都对缓存资源进行验证（所以并不是 'no-cache' 的字面意思？）</li>\n<li><code class=\"language-text\">public</code> 可被中间人（CDN，中间代理）缓存</li>\n<li><code class=\"language-text\">private</code> 与上条相反</li>\n<li><code class=\"language-text\">max-age</code> 制定过期时间</li>\n<li><code class=\"language-text\">must-revalidate</code> 必须重新验证，那不合 'no-cache' 一样吗？</li>\n</ul>\n<p>验证的机制</p>\n<p>MDN 上说 <code class=\"language-text\">ETags</code> 是强校验器，而 <code class=\"language-text\">Last-Modified</code> 可以作为一种弱校验器，但没说强和弱在哪里？(看到了，我大概眼睛不好使。<code class=\"language-text\">Last-Modified</code>说它弱是因为有效期只有 1s)</p>\n<ul>\n<li><code class=\"language-text\">ETags</code> 资源的指纹（比如哈希）。总之就是缓存过了有效期限之后，向服务端发送请求并附带 <code class=\"language-text\">If-None-Match</code> 头(值为 ETags 的值)，服务端进行验证。如果通过则 304 (Not Modified)，同时更新过期时间; 否则 200(OK) 并附带更新的资源。</li>\n<li><code class=\"language-text\">Last-Modified</code> 对应<code class=\"language-text\">If-Modified-Since</code>，与上述类似的逻辑。</li>\n</ul>\n<p>还有 <code class=\"language-text\">Vary</code> 也算是缓存控制吧，指定某个（头|属性），比如 <code class=\"language-text\">Vary: User-Agent</code> 第一次请求缓存了 <code class=\"language-text\">User-Agent: Firefox</code> 的某资源，第二次请求用 <code class=\"language-text\">User-Agent: Chrome</code> 请求同一资源就不会用第一次的缓存。</p>\n</li>\n<li>\n<p>TCP 三次握手四次挥手</p>\n<p>答：C: Hello, S: Recvice, ...</p>\n<hr>\n<p>三次握手其实也差不多，大意：C: Hello, S: Recvice, C: Ack</p>\n<p>四次挥手，C:Fin, S: ACK, S: Fin, C: ACK</p>\n<p>客户端发起结束连接的报文，所以它不再需要发送数据了。但是服务端可能还有数据没有发送完成，可以在 “S: ACK, S: Fin” 之间继续发送。</p>\n</li>\n<li>\n<p>CSS 垂直水平居中</p>\n<p>答：水平居中可以用 <code class=\"language-text\">margin: 0 auto;</code>, 锤子的话我一般用 Flex Box 或者 Grid，（还知道别的方式吗？）不知...</p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/imbillow/image-storage/master/imagesCSS-vertical-center.webp\" alt=\"imagesCSS-vertical-center.webp\"></p>\n<p>...这不和</p>\n<blockquote>\n<p>你可知茴字有几种写法？</p>\n</blockquote>\n<p>一样吗？一直觉得用 table 来布局怪怪的。</p>\n<p>12 种写法大部分都挺 tricky, 感觉除了 Flex box 和 Grid 外，只用记一个 line-height = height （其实我知）和 绝对定位 + <code class=\"language-text\">top:50%</code> + (<code class=\"language-text\">margin-top: -height/2</code> | <code class=\"language-text\">transform: translate(0, -50%)</code>)</p>\n<p>然后兼容性：</p>\n<p><img src=\"https://raw.githubusercontent.com/imbillow/image-storage/master/imagescompatible-flex.webp\" alt=\"imagescompatible-flex.webp\"></p>\n<p><img src=\"https://raw.githubusercontent.com/imbillow/image-storage/master/imagescompatible-transform.webp\" alt=\"imagescompatible-transform.webp\"></p>\n</li>\n<li>\n<p>数据结构 堆</p>\n<p>答：只记得堆是压扁的树（仅存的印象），其它的就不知了。（然后又问了啥链表、数组、栈、队列）</p>\n<hr>\n<p>实际上堆只是父节点比子节点小（或大）的树而已，我之所以有压扁的印象是因为 cpp 的堆是用数组实现的（也没有了解太多，只对那张图有点印象）。\n它也有别的名字，比如优先队列？或者说一般优先队列都是用的堆来实现的。\n优先队列和普通的先进先出有点不同就是，每个元素都有个优先级，优先级高（或低）的可以直接插队到前面。</p>\n</li>\n</ol>"}},"pageContext":{"id":"f4601566-d342-5c26-9d74-4ec686a9c0fa"}},"staticQueryHashes":[]}